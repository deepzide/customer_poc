name: Deploy to server

on:
  push:
    branches: [ main ]
  workflow_dispatch:
  workflow_call:
    inputs: {}
    secrets:
      DOCKER_USER:
        required: true
      DOCKER_TOKEN:
        required: true
      SSH_KEY_PRIVATE:
        required: true

env:
  SERVER_IP: 46.62.156.99
  CUSTOM_APP_NAME: custom_app # Nombre de tu carpeta con la app custom

jobs:
  build:
    runs-on: self

    steps:
      # 1️⃣ Checkout repo (obtiene tu código, incluyendo ./custom_app)
      - name: Checkout repository
        uses: actions/checkout@v4

      # 2️⃣ Configure SSH for private repos
      - name: Configure SSH access
        run: |
          mkdir -p ~/.ssh
          echo "${{ secrets.SSH_KEY_PRIVATE }}" > ~/.ssh/id_rsa
          chmod 600 ~/.ssh/id_rsa
          ssh-keyscan github.com >> ~/.ssh/known_hosts

      # 3️⃣ Encode apps.json (Solo apps base)
      - name: Encode apps.json
        id: encode
        run: |
          export APPS_JSON_BASE64=$(base64 -w 0 apps.json)
          echo "APPS_JSON_BASE64=$APPS_JSON_BASE64" >> $GITHUB_ENV

      # 4️⃣ Clone frappe_docker
      - name: Clone frappe_docker
        run: git clone https://github.com/frappe/frappe_docker

      # 4.1️⃣ Inyectar código custom en el Containerfile (MÉTODO GREP/CAT - A PRUEBA DE ERRORES)
      - name: Inject custom app installation into Containerfile
        run: |
          CFG_FILE="./frappe_docker/images/layered/Containerfile"
          APP_NAME="${{ env.CUSTOM_APP_NAME }}"
          
          # ANCLA (Búsqueda literal, sin regex, escapando '$' para el shell)
          ANCHOR='FROM frappe/base:${FRAPPE_BRANCH} AS backend'
          
          # 1. Crear archivo temporal
          TMP_FILE=$(mktemp)
          
          # 2. Volcar contenido ANTES del ancla (sin incluir la línea del ancla)
          # Usamos grep -F (búsqueda literal) y head -n -1 (quitar la última línea)
          grep -B 999 -F -m 1 "$ANCHOR" "$CFG_FILE" | head -n -1 > "$TMP_FILE"

          # 3. Echar nuestro bloque de inyección (usando 'cat <<EOF')
          # ¡El 'EOF' DEBE estar al inicio de la línea, sin indentación!
          cat >> "$TMP_FILE" <<EOF

          # ----------------------------------------------------------------------
          # [CAPA CORTA - INYECCIÓN CUSTOM]
          # ----------------------------------------------------------------------
          COPY --chown=frappe:frappe ./$APP_NAME /home/frappe/frappe-bench/apps/$APP_NAME

          USER frappe
          WORKDIR /home/frappe/frappe-bench
          #RUN bench install-app $APP_NAME --site fronted

          EOF

          # 4. Volcar el ANCLA y el resto del archivo
          grep -A 999 -F -m 1 "$ANCHOR" "$CFG_FILE" >> "$TMP_FILE"
          
          # 5. Reemplazar el archivo original
          mv "$TMP_FILE" "$CFG_FILE"
        
      # 4.2️⃣ DEBUG: Mostrar Containerfile modificado
      - name: Show modified Containerfile
        run: |
          echo "====================================================="
          echo "CONTENIDO DEL Containerfile DESPUÉS DE LA INYECCIÓN"
          echo "====================================================="
          cat ./frappe_docker/images/layered/Containerfile
          echo "====================================================="

      # 5️⃣ Set up Docker Buildx
      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      # 6️⃣ Login to DockerHub
      - name: Login to DockerHub
        uses: docker/login-action@v3
        with:
          username: ${{ secrets.DOCKER_USER }}
          password: ${{ secrets.DOCKER_TOKEN }}

      # 7️⃣ Build and push custom ERPNext image (Usa contexto: .)
      - name: Build and push custom ERPNext image
        uses: docker/build-push-action@v5
        with:
          context: . 
          file: ./frappe_docker/images/layered/Containerfile
          push: true 
          tags: ${{ secrets.DOCKER_USER }}/deepzide:latest
          build-args: |
            FRAPPE_PATH=https://github.com/frappe/frappe
            FRAPPE_BRANCH=version-15
            APPS_JSON_BASE64=${{ env.APPS_JSON_BASE64 }}
          cache-from: |
            type=gha
            type=registry,ref=${{ secrets.DOCKER_USER }}/deepzide:latest
          cache-to: type=gha,mode=max

  ansible:
    needs: build
    runs-on: ubuntu-latest

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Setup SSH key
        run: |
          mkdir -p ~/.ssh
          chmod 700 ~/.ssh
          echo "${{ secrets.SSH_KEY_PRIVATE }}" | base64 --decode > ~/.ssh/erpnext_deploy_key
          chmod 600 ~/.ssh/erpnext_deploy_key
          ssh-keyscan -H ${{ env.SERVER_IP }} >> ~/.ssh/known_hosts 2>/dev/null
          ssh -i ~/.ssh/erpnext_deploy_key -o StrictHostKeyChecking=no root@${{ env.SERVER_IP }} "echo 'SSH connection successful!'"

      - name: Create dynamic inventory
        run: |
          SSH_KEY_PATH="${HOME}/.ssh/erpnext_deploy_key"
          cat > ./ansible/inventory.ini <<EOF
          [erpnext]
          ${{ env.SERVER_IP }} ansible_user=root ansible_ssh_private_key_file=${SSH_KEY_PATH}
          EOF
          cat ./ansible/inventory.ini

      - name: Test Ansible connection
        run: |
          ansible all -i ./ansible/inventory.ini -m ping

      - name: Deploy docker-compose via Ansible
        run: |
          ansible-playbook -i ./ansible/inventory.ini ./ansible/docker_erpnext.yml -v
